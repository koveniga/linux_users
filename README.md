Описание:
--------------

Создание и удаление linux пользователей (приведение к состоянию указанному в репозитории), без учета их ID

Доступные теги:
--------------

* show -выведет состояние dict linux_groups определенного в репозитории, а так же какие группы должны присутствовать на хосте, а какие будут удалены (после сравнения)
* show_modified - вывод (в том, числе таргетированно) информации, которую роль применяет к таскам установки пользователя и его групп (после всех изменений)
* debug -покажет какие группы должны присутствовать на хосте, а какие будут удалены (если появились новые группы или группы, подлежащие удалению = покажет их в fatal: ... (failed task)
* target_user - позволяет сфокусироваться на установке пользователей (без удаления) (таргетирование опционально target_user)
* authkeys_target - позволяет сфокусироваться только на ключах конкретного пользователя (не затрагивая других) (опционально с переменной target_user), каталог пользователя .ssh должен быть уже создан, если идет установка ключей (DEPRECATED)
* authkeys_all - позволяет сфокусироваться только на ключах пользователей, каталог .ssh у пользователей должен быть создан, если потребуется установка ключей
* restrict_user - позволяет выполнить только таску удаления пользователей (или пользователя, если задана переменная target_user)


Доступные переменные:
--------------
* users_role_behaviour - переменная позволяющая задать поведение роли users (рекомендуется указывать в переменных инвентаря для хоста, а не через extra vars):
  * users_role_behaviour=='manage_defined_only' (Default) == роль будет управлять только теми пользователями, что указаны в репозитории (dict users), если на хосте присутствуют другие пользователи - роль их игнорирует и ничего с ними не делает
  * users_role_behaviour=='all_state_in_repo' == состояние в репозитории эталонное: если на хосте присутствуют пользователи, которые не указаны в репозитории (dict users) - роль их попытается удалить
* target_user - позволяет сфокусироваться на обработке только конкретного пользователя (не затрагивая других), если идет в паре с тегом target_user - будет попытка установки, если с тегом restrict_user - то будет попытка удаления. Допускается перечислить нескольких пользователей через запятую ','
* not_check_ssh_keys - позволяет не пробегать таски, которые управляют ключами пользователя (использовать либо для дебага, либо когда не нужно затрагивать\верифицировать ключи установленным пользователям); Если not_check_ssh_keys=True, таски установки ключей затронуты не будут, если False (равно как undefined) == выполнить таски 

Пример описания пользователя для хоста
--------------

Используются 2 dict'а и 1 переменная:
1. users_role_behaviour: <string>   # Задание поведения роли, допустимые значения
                                    # 'manage_defined_only' (Default) ==> роль будет управлять только теми пользователями,
                                    #       что указаны в репозитории (dict users), если на хосте присутствуют другие
                                    #       пользователи - роль их игнорирует и ничего с ними не делает
                                    # 'all_state_in_repo' ==> состояние в репозитории эталонное: если на хосте присутствуют пользователи,
                                    #       которые не указаны в репозитории (dict users) - роль их попытается удалить
2. users - определяет какие пользователи должны быть на хосте (или не должны быть)
3. users_db - определяет параметры пользователя

#### Общий вид описания dict users
```
users:
  <user_name>:
    enabled: <True|False> (required)
```
#### Частный пример описания dict users
```
users:
  admin:
    enabled: True
  sysadmin:
    enabled: True
  someuser:
    enabled: False
```
В данном случае для хоста:
1. пользователь admin, sysadmin будут обработаны, как пользователи, которые должны быть на хосте
2. пользователь someuser, будет удален (вычищен из /etc/passwd, /etc/shadow)

#### Общий вид описания dict users_db
````
users_db:
  <user_name>:
    astra_ilevel: <integer> (optional)                            # Уровень целостности для пользователя в случае прокатки на Astra Linux (если не задан - установка не производится)
    passwd: '<password hash>' (required)                          # Хеш пароля, который будет установлен пользователю (или '!' или '*', если не требуется) (определяется в /etc/shadow)
    main_groupname: '<groupname>' (required)                      # Имя главной группы пользователя (определяется в /etc/passwd) - будет создана с warning, если не существовала
    user_home: '<some_path>' (required)                           # Домашний каталог пользователя (определяется в /etc/passwd)
    user_shell: '<some_executable>' (required)                    # интерпретатор команд пользователя (как правило для обычных пользователей: /bin/bash)
    user_comment: '<come_comment>' (optional)                     # Комментарий для пользователя (определяется в /etc/passwd), в настоящее время не устанавливается
    system: <True|False> (optional)                               # Флаг того, что пользователь является системным (по умолчанию: False)
    ssh_dir_present: <True|False> (optional)                      # Флаг того, что у пользователя должна быть директория .ssh в <user_home> (установит или удалит ее) (default: True)
    no_auth_file: <True|False (optional)                          # Флаг того, что у пользователя есть (False) или нет (True) файл для авторизации по ключам (удалит его если True)
                                                                  # (default: False)
    create_home: <True|False> (optional)                          # Флаг создавать или нет домашний каталог пользователя (default: True), модулем ansible.builtin.user
    skip_setup_groups_task: <True|False> (optional)               # Флаг роли применять (False) или нет (True) накатку дополнительных групп для пользователя (default: False)
    groups: (optional)                                            # Указание, что у пользователя могут быть дополнительные группы
      <groupname>: <True|False> (required)                        # True - у пользователя должна быть указанная группа (groupname), False - не должна быть
    ssh_owner: <username> (optional)                              # Указание какой пользователь будет владельцем директории .ssh (default: <user_name>)
    ssh_group: <groupname> (optional)                             # Указание какая группа будет назначена директории .ssh (default: <user_name>), группа должна существовать
    ssh_dir_mode: <filemode> (optional)                           # Указание прав для директории .ssh (default: "0700")
    skip_auth_file_setup: <True|False> (optional)                 # Указание, что файл авторизации затрагивать не нужно
    auth_keys_file_owner: <username> (optional)                   # Указание какой пользователь будет владельцем для файла авторизации (default: <user_name>)
    auth_keys_file_group: <groupname> (optional)                  # Указание какая группа будет назначена файлу авторизации (default: <user_name>), группа должна существовать
    auth_keys_file_mode: <filemode> (optional)                    # Указание прав для файла (default: "0600")
    auth_keys: (optional)                                         # Указание, что у пользователя для хоста могут быть авторизационные ключи
      <any_keyname>: (required)                                   # Совершенно любое имя для ключа (по этому имени можно обращатся для переопределения из групповых переменных)
        enabled: <True|False> (requrired)                         # True - ключ будет установлен, False - ключ будет выпилен
        datafile: templates/ssh-keys/<filename> (required)        # Ассоциировать этот dict-key с этим файлом

Пример playbook
--------------

```
---
- hosts: linux
  become: True
  become_method: sudo
  serial: N # ввиду особенностей работы шедулера ansible при include_tasks
            #   при прогоне по всем пользователям и всем хостам лучше разбить PLAY на N хостов
            #   это позволит ускорить обработку всех хостов, конкретное значение зависит от хоста (cpu/ram/network),
            #   где выполняется playbook. 30<=N<=50 кажется оптимальным. При таргетировании serial лучше не задавать вовсе
  roles:
    - users
```

Примечание (условности) и другие полезности
--------------

В Debian-based хостах группы пользователей 'wheel' будут заменены на 'sudo'. Чтобы не пилить разные уровни пользовательских групп в ansible и прочее --> если целевой хост Debian-like, то происходит замена групп 'wheel' на 'sudo'. Это позволяет не плодить в инвентаре разные наборы однотипных пользователей, которым разрешено выполнение sudo по членству в системной группе (wheel == RedHat Based, sudo == Debian based). Это конечно же приводит к тому, что нельзя нормально (да и зачем?) оперировать группой wheel в Debian-based системах; дополнительно: на хостах Astra Linux производится замена группы 'wheel' на 'astra-admin'

Если при прокатке какой-либо item цикла зафаталился и по сообщению непонятно, что это за item был --> использовать тег 'show' -> в выводе будет Present_users_to_manage и users_to_manage_to_disable ==> список всех элементов к обработке, который исполняется по порядку (от предыдущего успешного элемента можно понять какой будет следующий, на котором был фатал)

Запуск playbook
--------------

```
ansible-playbook -i inventory -l <some_host> playbooks/users.yml -t debug 
ansible-playbook -i inventory -l <some_host> playbooks/users.yml -t show
ansible-playbook -i inventory -l <some_host> playbooks/users.yml -t target_user -e target_group=<some_user> [-CD]
ansible-playbook -i inventory playbook/users.yml [-CD]
ansible-playbook -i inventory playbook/users.yml -e not_check_ssh_keys=True -CD <== так можно проверить не изменятся ли настройки какого-либо пользователя (без учета его ключей)
```
